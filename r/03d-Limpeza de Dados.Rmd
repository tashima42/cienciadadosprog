---
title: Limpeza de Dados
output: html_document
---


Os processos de limpeza e preparação de dados são muito importantes. Dados limpos, completos e organizados tornam as análises mais fáceis e confiáveis. Abaixo descrevemos alguns dos principais mecanismos para tratar dados que tenham algum problema.

Execute cada célula de código abaixo para ver o resultado.

## Leitura e análise inicial dos dados


```{r, message=FALSE}
#importação de bibliotecas
library(dplyr)
library(tidyr)

# lê o arquivo CSV
df <- read.csv('../data/aluguel-com-erros.csv', header = T, sep=",", stringsAsFactors = FALSE)

```


O primeiro passo ao se analisar dados desconhecidos é visualizar algumas linhas de dados:

```{r}
head(df)
```

A função `summary` é útil para vermos quais colunas do DataFrame tiveram seus tipos de dados corretamente identificados pelo R. No caso abaixo já é possível identificar alguns problemas. As colunas *area, aluguel e condomínio* foram interpretadas como caracteres de texto (string) enquanto deveriam ser numéricas. A coluna *data* deveria ser do tipo `Date`.


```{r}
summary(df)
```

## Localizando e tratando valores inválidos

Valores inválidos ou não existentes podem ser convenientemente representados pelo valor NA (not available). Mas para que isto seja possível, é preciso indicar quais valores devem ser considerados NA. Uma rápida avaliação dos dados do csv (você pode editar o arquivo em um editor, por exemplo) mostra que diversos campos estão sem valor e alguns são marcados com o caracter `?`. Para que a leitura do arquivo reconheça os valores inválidos e ausentes como NA, podemos incluir o parâmetro `na.strings` como no exemplo abaixo.

```{r}
df <- read.csv('../data/aluguel-com-erros.csv', header = T, sep=",", stringsAsFactors = FALSE, na.strings=c("","NA", "?"))
df
```
Com os NA representados adequadamente, podemos usar diversas funções que os referenciam. Por exemplo, abaixo usamos o teste `is.na` para identificar as linhas que contenham valores nulos em qualquer variável (coluna).
```{r}
df %>%
  filter_all(any_vars(is.na(.)))
```
O apartamento com código 44803 mostrado acima tem muitos campos vazios. Uma boa estratégia neste caso é eliminar esta linha. O comando abaixo define um novo DataFrame sem este apartamento.

```{r}
df_sem_nulos <- df %>%
  filter(codigo != '44803')

df_sem_nulos
```


Se você quer eliminar as linhas com valores nulos em uma determinada coluna, basta usar o `drop_na()` especificando a coluna. Se quiser eliminar todas as linhas com valores nulos em qualquer coluna, use `drop_na()` sem especificar colunas.

```{r}
df %>% drop_na(endereco)
```

Podemos usar o método `fillna` para substituir os valores em branco por um valor definido, neste caso a *String* "Desconhecido". Após a substituição não há mais valores em branco no campo `endereco`.
```{r}
df_sem_nulos <- df_sem_nulos %>% 
  mutate(endereco = replace_na(endereco, "desconhecido"))

df_sem_nulos
```

Podemos também fazer substituições de partes das *strings* no DataFrame. Por exemplo, podemos padronizar ruas e avenidas com as abreviações R. e Av. O código abaixo faz isto:

```{r}
library(stringr)

df_sem_nulos <- df_sem_nulos %>%
  mutate(endereco = str_replace(endereco, "Rua", "R.")) %>%
  mutate(endereco = str_replace(endereco, "Avenida", "Av.")) 

df_sem_nulos
```

## Conversão de tipos

Como pode ser visto pela execução do método `str` abaixo, as colunas ainda possuem tipos incorretos. Precisamos então fazer a conversão manual dos tipos.

```{r}
str(df_sem_nulos)
```

Para uma coluna com datas, precisamos usar o `as.Date`. O componente `format` especifica o formato da data. `"%d/%m/%y"` representa datas como 23/04/67 enquanto `"%d-%m-%Y"` representa 23-04-1967.

```{r}
df_ajustado <- df_sem_nulos %>% 
  mutate(data = as.Date(data, format= "%d/%m/%y"))

# Verificando nulos
df_ajustado %>%
  filter_all(any_vars(is.na(.)))
```
Após converter a coluna para o tipo Date, temos ainda uma linha com um valor NA. Podemos ver os dados no DataFrame original para entender o problema:
```{r}
df %>% filter(codigo == 82343)
```
No resultado acima podemos ver que o valor original de data para o registro é "janeiro 17". Precisamos então substituir este valor antes de fazer a conversão para data:
```{r}
df_sem_nulos <- df_sem_nulos %>%
  mutate(data = str_replace(data, 'janeiro 17', '01/01/17'))

df_sem_nulos
```

Como substituímos o valor com problema, conseguimos converter corretamente a coluna:

```{r}
df_ajustado <- df_sem_nulos %>% 
  mutate(data = as.Date(data, format= "%d/%m/%y"))

df_ajustado %>%
  filter_all(any_vars(is.na(.)))
```


Agora podemos conferir os tipos e verificar que estão todos corretos:

```{r}
str(df_ajustado)
```

Para converter as colunas para os tipos adequados, usamos o método `astype`. Podemos tanto aplicar a uma coluna por vez ou em várias colunas. No código abaixo convertemos `aluguel` e `condominio` para o tipo numeric (números reais, com casas decimais):

```{r}
df_ajustado <- df_ajustado %>% 
  mutate_at(c("aluguel", "condominio"), as.numeric)

str(df_ajustado)
```
E podemos fazer ajustes, como corrigir os valores de aluguel de acordo com um índice de inflação:

```{r}
df_ajustado <- df_ajustado %>% 
  mutate(aluguel = aluguel * 1.162)

head(df_ajustado)
```


Com todos os tipos convertidos corretamente, podemos aplicar funções estatísticas e exibir corretamente os valores em gráficos como mostrado abaixo:

```{r}
paste('Média do aluguel (dados sujos):', mean(df$aluguel))

paste('Média do aluguel (dados limpos): ', mean(df_ajustado$aluguel))
```
```{r}
plot(condominio ~ aluguel, data=df_ajustado)
```

## Identificando outliers

Outliers são valores fora da faixa esperada para uma observação. Um forma conveniente de identificar outliers é usando BoxPlots. Abaixo podemos perceber que existem dois valores de condomínio fora do que seria esperado (mostrados como círculos abaixo e acima da caixa).

```{r}
boxplot(df_ajustado$condominio)
```

Outra forma de identificar outliers é calcular os *z-scores* para uma variável. O z-score fornece informação sobre o quão inesperado um valor é considerando os demais valores presentes. Abaixo calculamos os z-scores para a variável condomínio. Veja que um valor 'inesperado' é o 120 com z-score -1.3, indicando que é um valor mais baixo que o esperado. O outro outlier é o de condomínio 1100 com z-score 3.7 indicando que está muito acima do esperado. Em geral valores de z-score abaixo de -3 e acima de +3 são fortes candidados a serem outliers.

```{r}
df_ajustado %>% 
  mutate(condominio_zscore = (condominio - mean(condominio))/sd(condominio)) %>%
  arrange(condominio_zscore)
```

Uma possibilidade para eliminar o valor que está muito acima seria excluir a linha que o contém. O problema disso é que perderíamos todos os dados da linha, que inclui dados aparentemente corretos. Uma forma de manter os dados corretos e ao mesmo tempo minimizar a influência do valor incorreto é substituir o valor incorreto pela média dos demais valores para a variável, como fazemos abaixo. Veja que agora o valor de condomínio para a linha problemática é 379.84.

```{r}
df_ajustado <- df_ajustado %>% 
  mutate(condominio = replace(condominio, condominio == 1100, mean(condominio)))

df_ajustado
```

## Escrevendo os dados limpos no disco

Para salvar os dados limpos em um arquivo, usamos a função `write.csv`, como no exemplo abaixo:

```{r}
write.csv(df_ajustado, file = '../data/aluguel-limpo.csv', row.names = FALSE)
```

